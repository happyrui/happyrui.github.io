<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript基础之作用域,闭包,this,执行上下文]]></title>
    <url>%2F2019%2F10%2F12%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85-this-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
    <content type="text"><![CDATA[作用域作用域： 变量与函数的可访问范围量 分为 全局作用域： 在代码中任何地方都能访问到的对象拥有全局作用域 局部作用域： 一般只在固定的代码片段内可访问到。最常见的是在函数体内定义的变量，只能在函数体内使用。 在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。 声明提前：JavaScript 函数里声明的所有变量（但不涉及赋值）都被「提前」至函数体的顶部由于 JavaScript 没有块级作用域，因此一些程序员特意将变量声明放在函数体顶部，而不是将声明靠近放在使用变量之处。这种做法使得他们的源代码非常清晰地反映了真实的变量作用域。 1234567891011121314var color = "blue";function changeColor()&#123; var anotherColor = "red"; function swapColors()&#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; // 这里可以访问color、anotherColor和tempColor &#125; // 这里可以访问color和anotherColor，但不能访问tempColor swapColors();&#125;// 这里只能访问colorchangeColor(); 全局环境、changeColor() 的局部环境和 swapColors() 的局部环境。 全局环境中有一个变量 color 和一个函数 changeColor()。changeColor() 的局部环境中有一个名为 anotherColor 的变量和一个名为 swapColors() 的函数，但它也可以访问全局环境中的变量 color。swapColors() 的局部环境中有一个变量tempColor，该变量只能在这个环境中访问到。无论全局环境还是 changeColor() 的局部环境都无权访问 tempColor。然而，在 swapColors() 内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。 JS执行机制闭包由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成定义在一个函数内部的函数 用处有两个: 一个是可以读取函数内部的变量（作用域链）， 另一个就是让这些变量的值始终保持在内存中。 123456789101112131415function fun() &#123; var n = 1; add = function() &#123; //add 是一个全局变量，add 的值是一个匿名函数。而这个匿名函数本身也是一个闭包，和 fun2 处于同一作用域，所以 add 相当于是一个 setter，可以在函数外部对函数 内部的局部变量进行操作 n += 1 &#125; function fun2()&#123; console.log(n); &#125; return fun2;&#125;var result = fun(); result(); // 1add();result(); // 2 1234567891011121314function fun() &#123; var n = 1; var add = function() &#123; n += 1 &#125; function fun2()&#123; console.log(n); &#125; return fun2;&#125;var result = fun(); result(); // 1add();result(); // 1 使用闭包解决一些问题： 1234567891011var add = function() &#123; var counter = 0; var plus = function() &#123;return counter += 1;&#125; //闭包 return plus;&#125;var puls2 = add();console.log(puls2());console.log(puls2());console.log(puls2());// 计数器 counter 受 add() 函数的作用域保护，只能通过 puls2 方法修改。 使用闭包的注意事项: 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除或设置为 null，断开变量和内存的联系。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（public method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 thisthis 是 JavaScript 的关键字，指函数执行时的上下文，跟函数定义时的上下文无关。随着函数使用场合的不同，this 的值会发生变化。但是有一个总的原则，那就是 this 指代的是调用函数的那个对象。 全局上下文 在全局上下文中，也就是在任何函数体外部，this 指代全局对象。 12// 在浏览器中，this 指代全局对象 windowconsole.log(this === window); // true 函数上下文 在函数上下文中，也就是在任何函数体内部，this 指代调用函数的那个对象。 函数调用中的 this 1234function f1()&#123; return this;&#125;console.log(f1() === window); // true 如上代码所示，直接定义一个函数 f1()，相当于为 window 对象定义了一个属性。直接执行函数 f1()，相当于执行 window.f1()。所以函数 f1() 中的 this 指代调用函数的那个对象，也就是 window 对象。 12345function f2()&#123; "use strict"; // 这里是严格模式 return this;&#125;console.log(f2() === undefined); // true 如上代码所示，在「严格模式」下，禁止 this 关键字指向全局对象（在浏览器环境中也就是 window 对象），this 的值将维持 undefined 状态。 对象方法中的 this 1234567var o = &#123; name: "stone", f: function() &#123; return this.name; &#125;&#125;;console.log(o.f()); // "stone" 如上代码所示，对象 o 中包含一个属性 name 和一个方法 f()。当我们执行 o.f() 时，方法 f() 中的 this 指代调用函数的那个对象，也就是对象 o，所以 this.name 也就是 o.name。 注意，在何处定义函数完全不会影响到 this 的行为，我们也可以首先定义函数，然后再将其附属到 o.f。这样做 this 的行为也一致。如下代码所示： 123456var fun = function() &#123; return this.name;&#125;;var o = &#123; name: "stone" &#125;;o.f = fun;console.log(o.f()); // "stone" 类似的，this 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法 g() 当作对象 o.b 的函数调用。在这次执行期间，函数中的 this 将指向 o.b。事实上，这与对象本身的成员没有多大关系，最靠近的引用才是最重要的。 12345o.b = &#123; name: "sophie" g: fun,&#125;;console.log(o.b.g()); // "sophie" eval() 方法中的 this eval() 方法可以将字符串转换为 JavaScript 代码，使用 eval() 方法时，this 指向哪里呢？答案很简单，看谁在调用 eval() 方法，调用者的执行环境中的 this 就被 eval() 方法继承下来了。如下代码所示： 1234567891011121314// 全局上下文function f1()&#123; return eval("this");&#125;console.log(f1() === window); // true// 函数上下文var o = &#123; name: "stone", f: function() &#123; return eval("this.name"); &#125;&#125;;console.log(o.f()); // "stone" call() 和 apply() 方法中的 this call() 和 apply() 是函数对象的方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this 指代的就是这两个方法的第一个参数。 12345678var x = 0; function f() &#123; console.log(this.x); &#125; var o = &#123;&#125;; o.x = 1;o.m = f; o.m.apply(); // 0 call() 和 apply() 的参数为空时，默认调用全局对象。因此，这时的运行结果为 0，证明 this 指的是全局对象。如果把最后一行代码修改为： 1o.m.apply(o); // 1 运行结果就变成了 1，证明了这时 this 指代的是对象 o。 bind() 方法中的 this ECMAScript 5 引入了 Function.prototype.bind。调用 f.bind(someObject) 会创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的。如下代码所示： 123456789101112131415function f() &#123; return this.a;&#125;var g = f.bind(&#123; a: "stone"&#125;);console.log(g()); // stonevar o = &#123; a: 28, f: f, g: g&#125;;console.log(o.f(), o.g()); // 28, stone DOM 事件处理函数中的 this 一般来讲，当函数使用 addEventListener，被用作事件处理函数时，它的 this 指向触发事件的元素。如下代码所示： 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id="btn" type="button"&gt;click&lt;/button&gt; &lt;script&gt; var btn = document.getElementById("btn"); btn.addEventListener("click", function()&#123; this.style.backgroundColor = "#A5D9F3"; &#125;, false); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 但在 IE 浏览器中，当函数使用 attachEvent ，被用作事件处理函数时，它的 this 却指向 window。如下代码所示： 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id="btn" type="button"&gt;click&lt;/button&gt; &lt;script&gt; var btn = document.getElementById("btn"); btn.attachEvent("onclick", function()&#123; console.log(this === window); // true &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 内联事件处理函数中的 this 当代码被内联处理函数调用时，它的 this 指向监听器所在的 DOM 元素。如下代码所示： 123&lt;button onclick="alert(this.tagName.toLowerCase());"&gt; Show this&lt;/button&gt; 上面的 alert 会显示 button，注意只有外层代码中的 this 是这样设置的。如果 this 被包含在匿名函数中，则又是另外一种情况了。如下代码所示： 123&lt;button onclick="alert((function()&#123;return this&#125;)());"&gt; Show inner this&lt;/button&gt; 在这种情况下，this 被包含在匿名函数中，相当于处于全局上下文中，所以它指向 window 对象。 执行上下文]]></content>
      <categories>
        <category>web前端</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础之回流重绘,正则]]></title>
    <url>%2F2019%2F10%2F12%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98-%E6%AD%A3%E5%88%99%2F</url>
    <content type="text"><![CDATA[回流与重绘 DOM回流(重排)：DOM树渲染完毕以后，只要页面中的HTML结构发生变化（增加删除元素、位置发生变化），浏览器都要重新计算一遍最新的DOM结构，重新对当前页面进行渲染；(reflow) DOM重绘：DOM树位置不发生变化，如元素的颜色背景发生变化，会只针对这个元素渲染，不渲染整个页面(repaint) DOM映射：页面中的标签和Js中获取到的元素对象（元素集合）是紧紧绑定在一起的，页面中HTML结构改变了，Js不需要重新获取，集合里面的内容也会跟着自动改变 减少回流和重绘 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。 千万不要使用 table 布局。因为可能很小的一个小改动会 造成整个 table 的重新布局。 setTimeout与setIntervalsetTimeout和setInterval的语法相同。它们都有两个参数，一个是将要执行的代码字符串，还有一个是以毫秒为单位的时间间隔，当过了那个时间段之后就将执行那段代码。 不过这两个函数还是有区别的， setInterval在执行完一次代码之后，经过了那个固定的时间间隔，它还会自动重复执行代码， setTimeout只执行一次那段代码。 区别： window.setTimeout(“function”,time)；//设置一个超时对象，只执行一次,无周期 window.setInterval(“function”,time)；//设置一个超时对象，周期＝’交互时间’ 停止定时： window.clearTimeout(对象) 清除已设置的setTimeout对象 window.clearInterval(对象) 清除已设置的setInterval对象 正则 正整数 /^[0-9]*[1-9][0-9]*$/; 负整数 /^-[0-9]*[1-9][0-9]*$/; 正浮点数 /^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$/; 负浮点数 /^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/; 浮点数 /^(-?\d+)(\.\d+)?$/; email地址 /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/; url地址 /^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$/; 年/月/日（年-月-日、年.月.日） /^(19|20)\d\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/; 匹配中文字符/[\u4e00-\u9fa5]/; 匹配帐号是否合法(字母开头，允许5-10字节，允许字母数字下划线) /^[a-zA-Z][a-zA-Z0-9_]{4,9}$/; 匹配空白行的正则表达式/\n\s*\r/`; 匹配中国邮政编码/[1-9]\d{5}(?!\d)/; 匹配身份证/\d{15}|\d{18}/; 匹配国内电话号码/(\d{3}-|\d{4}-)?(\d{8}|\d{7})?/; 匹配IP地址 /((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)/; 匹配首尾空白字符的正则表达式 /^\s*|\s*$/; 匹配HTML标记的正则表达式 &lt; (\S*?)[^&gt;]*&gt;.*?|&lt; .*? /&gt;; 匹配中文字符的正则表达式： [\u4e00-\u9fa5] 匹配双字节字符（包括汉字在内）：[^\x00-\xff] 匹配空行的正则表达式：\n[\s| ]*\r 匹配 HTML 标记的正则表达式：&lt;(.*)&gt;.*&lt;\/\1&gt;|&lt;(.*) \/&gt; 匹配首尾空格的正则表达式：(^\s*)|(\s*$) 匹配 IP 地址的正则表达式：/(\d+)\.(\d+)\.(\d+)\.(\d+)/g 匹配 Email 地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)* 匹配网址 URL 的正则表达式：http://(/[\w-]+\.)+[\w-]+(/[\w- ./?%&amp;=]*)? sql 语句：^(select|drop|delete|create|update|insert).*$ 非负整数：^\d+$ 正整数：^[0-9]*[1-9][0-9]*$ 非正整数：^((-\d+)|(0+))$ 负整数：^-[0-9]*[1-9][0-9]*$ 整数：^-?\d+$ 非负浮点数：^\d+(\.\d+)?$ 正浮点数：^((0-9)+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 非正浮点数：^((-\d+\.\d+)?)|(0+(\.0+)?))$ 英文字符串：^[A-Za-z]+$ 英文大写串：^[A-Z]+$ 英文小写串：^[a-z]+$ 英文字符数字串：^[A-Za-z0-9]+$ 英数字加下划线串：^\w+$ E-mail地址：^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$ URL：^[a-zA-Z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\s*)?$ 或：^http://[A-Za-z0-9]+.[A-Za-z0-9]+[/=?%-&amp;_~`@[]&#39;:+!]([^&lt;&gt;&quot;&quot;])$ 邮政编码：^[1-9]\d{5}$ 电话号码：^((\(\d{2,3}\))|(\d{3}\-))?(\(0\d{2,3}\)|0\d{2,3}-)?[1-9]\d{6,7}(\-\d{1,4})?$ 手机号码：^((\(\d{2,3}\))|(\d{3}\-))?13\d{9}$ 双字节字符（包括汉字在内）：^\x00-\xff 匹配首尾空格：(^\s*)|(\s*$) 匹配 HTML 标记：&lt;(.*)&gt;.*&lt;\/\1&gt;|&lt;(.*) \/&gt; 匹配空行：\n[\s| ]*\r 提取信息中的网络链接：(h|H)(r|R)(e|E)(f|F) *= *(&#39;|&quot;)?(\w|\\|\/|\.)+(&#39;|&quot;| *|&gt;)? 提取信息中的邮件地址：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)* 提取信息中的图片链接：(s|S)(r|R)(c|C) *= *(&#39;|&quot;)?(\w|\\|\/|\.)+(&#39;|&quot;| *|&gt;)? 提取信息中的 IP 地址：(\d+)\.(\d+)\.(\d+)\.(\d+) 提取信息中的中国手机号码：(86)*0*13\d{9} 提取信息中的中国固定电话号码：(\(\d{3,4}\)|\d{3,4}-|\s)?\d{8} 提取信息中的中国电话号码（包括移动和固定电话）：(\(\d{3,4}\)|\d{3,4}-|\s)?\d{7,14} 提取信息中的中国邮政编码：[1-9]{1}(\d+){5} 提取信息中的浮点数（即小数）：(-?\d*)\.?\d+ 提取信息中的任何数字 ：(-?\d*)(\.\d+)? IP：(\d+)\.(\d+)\.(\d+)\.(\d+) 电话区号：^0\d{2,3}$ 腾讯 QQ 号：^[1-9]*[1-9][0-9]*$ 帐号（字母开头，允许 5-16 字节，允许字母数字下划线）：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 中文、英文、数字及下划线：^[\u4e00-\u9fa5_a-zA-Z0-9]+$+]]></content>
      <categories>
        <category>web前端</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础之函数]]></title>
    <url>%2F2019%2F10%2F10%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[创建函数的方式函数声明和函数表达式12345678910// 函数表达式 匿名var foo1 = function(...)&#123;&#125;// 函数表达式 命名var foo2 = function acc(...)&#123;&#125;// 函数表达式 也就是立即执行函数(function()&#123;...&#125;)// 函数表达式setTimeout(funciton timer()&#123;...&#125;,200)// 函数声明function()&#123;...&#125; 函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。函数声明会绑定在自身的作用域中，而函数表达式会绑定在表达式自身的函数中，而不是所在作用域中。 箭头函数12// 没有returnacc = () =&gt; &#123;...&#125; 特点： 没有 this、super、arguments 和 new.target 绑定 箭头函数内部的这些值直接取自定义时的外围非箭头函数 不能通过 new 关键字调用 箭头函数没有 [[Construct]] 方法，所以不能被用作构造函数，如果通过 new 关键字调用箭头函数，程序会抛出错误。 没有原型 由于不可以通过 new 关键字调用箭头函数，因而没有构建原型的需求，所以箭头函数不存在 prototype 这个属性。 不可以改变 this 的绑定 函数内部的 this 值不可被改变，在函数声明周期内始终保持一致。 不支持 arguments 对象 箭头函数没有 arguments 绑定，所以你必须通过命名参数和不定参数这两种形式访问函数的参数。 不支持重复的命名参数 无论是在严格还是非严格模式下，箭头函数都不支持重复的命名参数；而在传统函数的规定中，只有在严格模式下才不能有重复的命名参数。 由于没有 this 的绑定，箭头函数的 this 值不受 call()、apply()、bind() 方法的影响。 箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj 构造函数与类在 ES6 Class 特性出现以前，我们经常使用 构造函数来模拟类的特性。思路基本都是：首先创建一个构造函数，然后定义另一个方法并复制给构造函数的原型。 123456789101112function Person(name) &#123; this.name = name&#125;Person.prototype.sayName = function() &#123; console.log(this.name)&#125; const person = new Person('Tumars')person.sayName() // "Tumars" console.log(person instance Person) // trueconsole.log(person instance Object) // true 上面代码中 Person 是一个构造函数，其执行后创建了一个名为 name 的属性；给 Person 的原型添加一个 sayName() 方法，所以 Person 对象的所有实例都会共享这个方法。由于存在原型继承的特性，person 对象是 Person 的实例，也是 Object 的实例。 通过构造函数创建的普通函数对象，拥有原型。 ES6 中的类是对构造函数写法的一种语法糖，它简化了构造函数的写法。 12345678910111213141516class PersonCLass &#123; constructor(name) &#123; this.name = name &#125; // 等价于 Person.prototype.sayName() sayName() &#123; console.log(this.name) &#125;&#125; const person = new Person('Tumars')person.sayName() // "Tumars" console.log(person instance PersonClass) // trueconsole.log(person instance Object) // true 通过类声明语法定义 PersonClass 的行为与之前创建 Person 构造函数的过程相似，只是这里直接在类中通过特殊的 constructor 方法名来定义构造函数，且由于这种类使用简介语法拉定义方法，因而不需要添加 function 关键字。 实例方法apply()、call() 使用 apply 与 call 调用函数被称为函数应用。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。 apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。 call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。 bind() bind()方法会创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 函数去抖与函数节流函数式编程声明式的，不可变的，没有副作用的是函数式编程的三大护法 纯函数 对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态的函数，叫做纯函数。 函数的柯里化 传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 高阶函数 高阶函数，就是把函数当参数，把传入的函数做一个封装，然后返回这个封装函数,达到更高程度的抽象。 123var checkage = min =&gt; (age =&gt; age &gt; min);var checkage18 = checkage(18); // 先将18作为参数，去调用此函数，返回一个函数age =&gt; age &gt; 18;checkage18(20);// 第二步，上面返回的函数去处理剩下的参数，即 20 =&gt; 20 &gt; 18; return true; 事实上柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法。 导图]]></content>
      <categories>
        <category>web前端</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础之常见算法]]></title>
    <url>%2F2019%2F10%2F10%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法 Algorithm Average Best Worst extra space stable 冒泡排序 O(N^2) O(N) O(N^2) O(1) 稳定 直接插入排序 O(N^2) O(N) O(N^2) O(1) 稳定 折半插入排序 O(NlogN) O(NlogN) O(N^2) O(1) 稳定 简单选择排序 O(N^2) O(N^2) O(N^2) O(1) 不稳定 快速排序 O(NlogN) O(NlogN) O(N^2) O(logN)~O(N^2) 不稳定 归并排序 O(NlogN) O(NlogN) O(NlogN) O(N) 稳定 堆排序 O(NlogN) O(NlogN) O(NlogN) O(1) 不稳定 计数排序 O(d*(N+K)) O(d*(N+K)) O(d*(N+K)) O(N+K) 稳定 冒泡: 依次比较相邻的两个数，如果不符合排序规则，则调换两个数的位置。这样一遍比较下来，能够保证最大（或最小）的数排在最后一位。再对最后一位以外的数组，重复前面的过程，直至全部排序完成。 12345678910111213function bubbleSort(arr)&#123; var len = arr.length; for(var i = 0;i&lt;len;i++)&#123; for(var j = 0;j&lt;len-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; //相邻元素两两比较 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j]=temp; &#125; &#125; &#125; return arr;&#125; 改进：设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。 12345678910111213141516function bubbleSort2(arr)&#123; var i=arr.length-1; //初始时,最后位置保持不变 while(i&gt;0)&#123; var pos=0;//每趟开始时,无记录交换 for(var j=0;j&lt;i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; pos=j;//记录交换的位置 var tmp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; &#125; &#125; i=pos;//为下一趟排序作准备 &#125; return arr;&#125; 选择: 选择排序（Selection Sort）与冒泡排序类似，也是依次对相邻的数进行两两比较。不同之处在于，它不是每比较一次就调换位置，而是一轮比较完毕，找到最大值（或最小值）之后，将其放在正确的位置，其他数的位置不变 12345678910111213141516function selectionSort(arr)&#123; var len=arr.length; var minIndex,temp; for(var i=0;i&lt;len-1;i++)&#123; minIndex=i; for(var j=i+1;j&lt;len;j++)&#123; if(arr[j]&lt;arr[minIndex])&#123; //寻找最小的数 minIndex=j; //将最小数的索引保存 &#125; &#125; temp=arr[i]; arr[i]=arr[minIndex]; arr[minIndex]=temp; &#125; return arr;&#125; 插入排序： 它将数组分成“已排序”和“未排序”两部分，一开始的时候，“已排序”的部分只有一个元素，然后将它后面一个元素从“未排序”部分插入“已排序”部分，从而“已排序”部分增加一个元素，“未排序”部分减少一个元素。以此类推，完成全部排序。 123456789101112function insertionSort(array) &#123; for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; return array;&#125; 希尔排序: 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量=1(&lt;…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止 123456789101112131415161718function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; while(gap &lt; len/5) &#123; //动态定义间隔序列 gap =gap*5+1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; return arr;&#125; 快速排序： 先确定一个“支点”（pivot），将所有小于“支点”的值都放在该点的左侧，大于“支点”的值都放在该点的右侧，然后对左右两侧不断重复这个过程，直到所有排序完成 12345678910111213141516function qSort(arr)&#123; if(arr.length==0)&#123; return []; &#125; var left=[]; var right=[]; var pivot=arr[0]; for(var i=1;i&lt;arr.length;i++)&#123; if(arr[i]&lt;pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return qSort(left).concat(pivot,qSort(right));&#125; 堆排序 将待排序的序列构造成一个最大堆，此时序列的最大值为根节点;依次将根节点与待排序序列的最后一个元素交换,再维护从根节点到该元素的前一个节点为最大堆，如此往复，最终得到一个递增序列 123456789101112131415161718192021222324252627282930function heapSort(array)&#123; //建堆 var heapSize=array.length,temp; for(var i=Math.floor(heapSize/2)-1;i&gt;=0;i--)&#123; heapify(array,i,heapSize); &#125; //堆排序 for(var j=heapSize-1;j&gt;=1;j--)&#123; temp=array[0]; array[0]=array[j]; array[j]=temp; heapify(array,0,--heapSize); &#125; return array;&#125;function heapify(arr,x,len)&#123; var l=2*x+1,r=2*x+2,largest=x,temp; if(l&lt;len&amp;&amp;arr[l]&gt;arr[largest])&#123; largest=l; &#125; if(r&lt;len&amp;&amp;arr[r]&gt;arr[largest])&#123; largest=r; &#125; if(largest!=x)&#123; temp=arr[x]; arr[x]=arr[largest]; arr[largest]=temp; heapify(arr,largest,len); &#125;&#125; 合并排序： 将两个已经排序的数组合并，要比从头开始排序所有元素来得快。因此，可以将数组拆开，分成n个只有一个元素的数组，然后不断地两两合并，直到全部排序完成 12345678910111213141516171819202122232425function mergeSort(arr)&#123; //采用自上而下的递归方法 var len=arr.length; if(len&lt;2)&#123; return arr; &#125; var middle=Math.floor(len/2), left=arr.slice(0,middle), right=arr.slice(middle); return merge(mergeSort(left),mergeSort(right));&#125;function merge(left,right)&#123; var result=[]; while(left.length&amp;&amp;right.length)&#123; if(left[0]&lt;=right[0])&#123; result.push(left.shift()); &#125;else&#123; result.push(right.shift()); &#125; &#125; while(left.length) result.push(left.shift()); while(right.length) result.push(right.shift()); return result;&#125; 数组操作 数组去重 1234567891011121314151617181920212223242526// 1、ES6新增方法Array.from(new Set(array)); // 2、indexOffunction unique(arr)&#123; var data = []; for(var i = 0; i&lt;arr.length;ix==) &#123; if(data.indexOf(arr[i]) == -1) &#123; data.push(arr[i]) &#125; &#125; return data;&#125;// 3、对象function unique(arr) &#123; var table = &#123;&#125;; var data = []; for(var i=0;i&lt;arr.length;i++) &#123; if(!table[arr[i]]) &#123; table[arr[i]] = true; data.push(arr[i]); &#125; &#125; return data;&#125;// 判断某个值是否只出现一次arr.indexOf(arr[i]) == arr.lastIndexOf(arr[i]) 数组中最大差值 最小与最大数的差值 1234567891011121314151617// 耗能大function MaxMin(arr) &#123; arr.sort(function(n1, n2) &#123;return n1-n2&#125;); return arr[arr.length-1] - arr[0];&#125;// function getMaxProfit(arr) &#123; var min = arr[0]; var max = 0; for(var i=0; i&lt;arr.length;i++)&#123; var current = arr[i]; min = Math.min(min, current); var p = current - min; max = Math.max(max, p); &#125; return max;&#125; 字符串操作 判断回文 1234567891011// 利用反转if(str == str.split('').reverse().join(''))&#123; console.log('是回文')&#125;// 利用字符下标for(var i=0;i&lt;str.length;i++)&#123; if(str.charAt(i)==str.charAt(len-1-i))&#123; console.log('是回文') &#125;&#125;// for循环反转拼接，再比较 反转 1str.split('').reverse().join('') 随机生成 1234567function randomString(n)&#123; var str = 'abcdefghijklmnopqrstuvwxyz0123456789'; var tmp = ''; for(var i=0;i&lt;n;i++) tmp += str.charAt(Math.round(Math.random()*str.length)); return tmp;&#125; 统计字符串中次数最多的字母 12 深拷贝，浅拷贝是什么js中有基础类型和引用类型。基础类型是存储在栈内存中的，按值存储，按值访问。基本类型有Number，String，Boolean，Null，Undefined，Symbol引用类型是存储在堆内存中的，值是可变的。在栈中保存对应的指针（一个指向堆的引用地址），指向堆中实际的值。比如数组，对象，正则等，除了基本数据类型，都是引用类型了。 基本类型的复制，是不会相互影响的。因为直接改变的就是栈中的值。而引用类型的复制，在修改其中一个的时候，另一个也会跟着发生变化。是因为复制的是栈中的指针，当改变值时，指针会仍然指向堆中实际的值，所以也就会跟着变化。 举一些例子吧：123456789101112131415161718// 基础类型var a = 2;b = a;console.log(b) //2b = 3;console.log(a, b) //2,3// 引用类型var arr = [2,4,6];var bcc = arr;//传址 ,对象中传给变量的数据是引用类型的，会存储在堆中；var cxx = arr[0];//传值，把对象中的属性/数组中的数组项赋值给变量，这时变量cxx是基本数据类型，存储在栈内存中；改变栈中的数据不会影响堆中的数据console.log(bcc);//2,4,6console.log(cxx);//2//改变数值 bcc[1] = 6;cxx = 7;console.log(arr[1]);//6console.log(arr[0]);//2 从上面我们可以得知，当我改变bcc中的数据时，arr中数据也发生了变化；但是当我改变cxx的数据值时，arr却没有发生改变。 这就是传值与传址的区别。因为arr是数组，属于引用类型，所以它赋予给bcc的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象。而cxx仅仅是从arr堆内存中获取的一个数据值，并保存在栈中。所以bcc修改的时候，会根据地址回到arr堆中修改，cxx则直接在栈中修改，并且不能指向arr堆内存中。 浅拷贝简单来说，引用类型的直接复制，在修改其中一个的时候，另一个就会跟着变化。这种直接复制的方式 就是浅拷贝。浅拷贝是拷贝一层，深层次的对象级别的就拷贝引用 还有一种浅拷贝的方式： ES6中的Object.assign方法，Object.assign是ES6的新函数。Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。 为了解决这个问题，引入深拷贝的方式，其实就是拷贝多层，每一级别的数据都会拷贝出来； 深拷贝的实现方式 手动复制 把一个对象的属性复制给另一个对象的属性 对象只有一层的话可以使用上面的：Object.assign()函数 JSON的方式，先转为字符串，再转为对象 JSON.parse(JSON.stringify(obj)) 缺点：会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。而且只有可以转为json格式对象的才能这样使用。 递归拷贝 1234567891011121314151617181920function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) &#123; continue; &#125; if (typeof prop === 'object') &#123; obj[i] = (prop.constructor === Array) ? [] : &#123;&#125;; arguments.callee(prop, obj[i]); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125;var str = &#123;&#125;;var obj = &#123; a: &#123;a: "hello", b: 21&#125; &#125;;deepClone(obj, str);console.log(str.a); Object.create()方法 123456789101112131415function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) &#123; continue; &#125; if (typeof prop === 'object') &#123; obj[i] = (prop.constructor === Array) ? [] : Object.create(prop); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125; 其他常见 十六进制颜色值的随机生成 12345678910function randomColor()&#123; var arrHex=["0","2","3","4","5","6","7","8","9","a","b","c","d"], strHex="#", index; for(var i=0;i &lt; 6; i++)&#123; index=Math.round(Math.random()*15); strHex+=arrHex[index]; &#125; return strHex;&#125; 阶乘 二分查找 JavaScript 面试中常见算法问题详解 一些常见算法的JavaScript实现 常见的js算法面试题收集，es6实现]]></content>
      <categories>
        <category>web前端</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础之Ajax,跨域]]></title>
    <url>%2F2019%2F10%2F10%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8BAjax-%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Ajax原理通过 XMLHttpRequest对象来向服务器发送异步请求，从服务器获得数据，然后用JS操作DOM，从而更新页面。 编写步骤 创建AJAX对象 XMLHttpRequest 打开一个连接 open(“GET”,URL,asnyc) 发送数据 send(); 事件处理函数，处理服务器的响应结果 onreadystatechange 实现步骤123456789101112131415161718192021//创建ajax对象var request=null;if(window.XMLHttpRequest)&#123; request = new XMLHttpRequest();&#125;else&#123; request = new ActiveXObject("Microsoft.XMLHTTP");&#125;//连接服务器request.open("GET",url,true);//发送请求request.send();//接收返回request.onreadystatechange = function()&#123; if(request.readyState==4 &amp;&amp; request.status==200)&#123; fnSucc(request.responseText); &#125;else&#123; if(fnFail)&#123; fnFail(); &#125; &#125;&#125; GET&amp;POST — — — — get 将数据放在URL(网址)里面来提交 安全性低 容量低,几K 获取数据 便于分享 如浏览帖子 可以缓存 post 将数据放在不是URL的地方 安全性一般 容量无限 上传数据 不便于分享 如用户注册 可以使用jquery封装好的$.ajax去异步获取后台的数据 12345678910111213$.ajax(&#123; type: "POST", url: url, data:&#123;&#125;,//数据 async: false,//同步 dataType: 'json', success: function (data) &#123; alert(JSON.stringify(data)) &#125;, error: function (XMLHttpRequest, textStatus, errorThrown) &#123; alert("报错"); &#125;&#125;); 跨域解决参考 jsonp在同源策略下，在某个服务器下的页面是无法获取到该服务器以外的数据的，但img、iframe、script等标签是个例外，这些标签可以通过src属性请求到其他服务器上的数据。 而JSONP就是通过script节点src调用跨域的请求。基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求 当我们通过JSONP模式请求跨域资源时，服务器返回给客户端一段javascript代码，这段javascript代码自动调用客户端回调函数 原生JS实现： 12345678910111213141516171819function createJs(sUrl)&#123; var oScript = document.createElement('script'); oScript.type = 'text/javascript'; oScript.src = sUrl; document.getElementsByTagName('head')[0].appendChild(oScript);&#125;createJs('jsonp.js');// src:// http://www.baidu.com/json/?callback=box// 回调函数function box(json)&#123; alert(json.name);&#125;// 服务器返回给客户端一段javascript代码// jsonp.jsbox(&#123; 'name': 'test' &#125;); Jquery实现 （使用封装的ajax） 1234567891011121314$.ajax(&#123; url:"http://localhost:8088/read.php", type:"GET", asnyc:false, dataType:"jsonp", jsonp: "callback", jsonpCallback:"box", success:function(data)&#123; alert(JSON.stringify(data.name)+" is "+JSON.stringify(data.age)+" years old"); &#125;, error:function()&#123; alert('fail'); &#125;&#125;); CORS解决跨域问题 跨域资源共享CORS 需要浏览器和服务端同时支持的，对于兼容性来说主要是ie10+，其它现代浏览器都是支持的。 document.domainwindow.nameHTML5中新引进的window.postMessageps:]]></content>
      <categories>
        <category>web前端</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础之事件]]></title>
    <url>%2F2019%2F10%2F10%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[事件模型 事件冒泡：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发，子级元素先触发 事件捕获：事件从最不精确的对象(document对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)，父级元素先触发 事件捕获阶段：事件从最上一级标签开始往下查找，直到捕获到事件目标(target)。 事件冒泡阶段：事件从事件目标(target)开始，往上冒泡直到页面的最上一级标 事件模型的各个阶段 捕获阶段-目标阶段-冒泡阶段 事件对象DOM事件模型中的事件对象常用属性: type用于获取事件类型 target获取事件目标 stopPropagation()阻止事件冒泡 preventDefault()阻止事件默认行为 IE事件模型中的事件对象常用属性: type用于获取事件类型 srcElement获取事件目标 cancelBubble = true 阻止事件冒泡 returnValue = false 阻止事件默认行为 W3C模型是将两者进行中和，在W3C模型中，任何事件发生时，先从顶层开始进行事件捕获，直到事件触发到达了事件源元素。然后，再从事件源往上进行事件冒泡，直到到达document。IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。ele.attachEvent(“onclick”, doSomething2); 使用jquery,既停止冒泡又阻止默认行为 123$("#testC").on('click',function()&#123; return false;&#125;); ele.addEventListener(‘click’,doSomething2,true)true=捕获 false=冒泡 事件委托事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件 页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件 xs.on事件=function(){} //相当于写一个函数。 处理兼容性问题 12var ev = ev || window.event;var target = ev.target || ev.srcElement; 12345678910111213141516window.onload = function()&#123; var Oul = document.getElementById('oul'); //var Oul = document.getElementsByTagName('ul'); //想要使用addEventListener，必须是dom元素，获取的是id值 Oul.addEventListener('click',function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; //不能直接使用target,必须有所转换再去匹配 if(target.nodeName.toLowerCase() == "li")&#123; alert(target.innerHTML); &#125; &#125;,false);// Oul.onclick= function()&#123;// alert('aaa')// &#125;&#125;]]></content>
      <categories>
        <category>web前端</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础之字符串数组操作]]></title>
    <url>%2F2019%2F10%2F10%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[数组 截取相关 slice 截取 不会影响原始数组 123456var arr = [1,2,3,4,5];// 截取 从 i 到 j的数组，不会改变原数组console.log(arr.slice(3)); // [4,5]console.log(arr); // [1,2,3,4,5]console.log(arr.slice(1,3)) // [2,3]console.log(arr); // [1,2,3,4,5] splice 删除，插入，替换 改变原始数组 12345678910var strArray = ['1', '2', 'd', 's', 'i'];//splice(i,j) 删除 以下标为i开始，截取j个元素strArray.splice(0,1); //已删除的 ["1"]console.log(strArray); //删除后的数组 ["2", "d", "s", "i"]//splice(i,0,j) 插入 以i开始，插入项,在 i 下标之前开始插入strArray.splice(1,0,'f','g','h'); console.log(strArray); // ["2", "f", "g", "h", "d", "s", "i"]//splice(i,n,j) 替换 以i开始，删除n项，插入其他项strArray.splice(1,1,'s','z'); // 即删除i及其后面n-1项，在插入其他项。console.log(strArray); // ["2", "s", "z", "g", "h", "2", "d", "s", "i"] 栈与队列操作（数组增加或删除元素） 12345678910var arr = [1,3,4,5,8,2,4,9];console.log(arr.push(5)); //在数组末尾添加元素console.log(arr);console.log(arr.pop()); //弹出栈顶那项 删除并返回数组的最后一个元素console.log(arr);console.log(arr.shift()); //删除并返回数组的第一个元素console.log(arr);console.log(arr.unshift(9)); //在数组头部添加元素console.log(arr); 重排序方法 reverse() 反转数组项的顺序 sort() 默认按照字符串排序a-z 12345678// 增加一个compare函数，实现对数值排序(升序或降序)var arr=[1,6,5,7,2,8,3];console.log(arr.reverse());function compare(value1,value2)&#123; return value1-value2; //升序 return value2-value1; //降序&#125;console.log(arr.sort(compare)); 迭代方法 every() 如果该函数对每一项都返回true，则返回true filter() 返回该函数会返回true 的项组成的数组 forEach() 这个方法没有返回值 map() 返回每次函数调用的结果组成的数组 some() 如果该函数对任意一项返回true，则返回true 迭代方法在数组的操作中是很常用的 arr.forEach()是和for循环一样，是代替for。arr.map()是修改数组其中的数据，并返回新的数据。 arr.forEach() 没有return arr.map() 有return 归并方法 reduce() 数组的逐个遍历，顺序 reduceRight() 逆序 12345678910var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur)&#123; return prev + cur;&#125;);var sum1 = values.reduceRight(function(prev, cur)&#123; return prev * cur;&#125;);console.log(sum); // 15console.log(sum1); // 120 其他方法 from() 将伪数组变成数组，就是只要有length的就可以转成数组 12// 有一个用法，数组去重Array.from(new Set(arr)) of() 将一组值转换成数组，类似于声明数组 find(callback) 找到第一个符合条件的数组成员 返回数组 findIndex(callback) 找到第一个符合条件的数组成员的索引值 返回number fill(target, start, end) 使用给定的值，填充一个数组,ps:填充完后会改变原数组 字符串 字符方法 chartAt(num) 返回字符串 中下标为 num 的字符，如果参数超出该范围，返回空字符串，如果没有参数，返回位置为0的字符; charCodeAt(num) 同上，返回 字符编码而不是字符 字符串操作方法 substring(i, j) 返回从 i到 j 的数据，不包括j 不改变原数据 substr(i, l) 返回从i开始，长度为l的数据 不改变原数据123const s = 'asasdadsadasd's.substr(1,4) // sasds.substring(2,5) // asd 字符串位置方法 indexOf()，参数为子字符串，从左至右查找，返回子字符串位置，如果没找到该子字符串，返回-1。 lastIndexOf()，参数为子字符串，从右至左查找，返回子字符串位置，如果没找到该子字符串，返回-1。 大小写转换 toLowerCase() ，创建原字符串的小写副本 toUpperCase() ，创建原字符串的大写副本 其他方法 trim()方法 该方法创建一个字符串的副本，删除前置和后缀的所有空格。 match() – 检查一个字符串是否匹配一个正则表达式。 replace() – 用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。 search() – 执行一个正则表达式匹配查找。如查找成功，返回字符串中匹配的索引值。否则返回 -1 split() 通过将字符串划分成子串，将一个字符串做成一个字符串数组 join() 将分割的字符数组连接成字符串，参数为连接的分隔符，默认为逗号1console.log(str1.split('').reverse().join('')); //字符串反转 通用方法 concat(a1, a2) 不改变原数据的值 连接两个数组 返回值为连接后的新数组 连接多个字符串，返回值为连接后的新字符串 slice(i, j) 截取 从 i 到 j，不会改变原数据，不包括 j]]></content>
      <categories>
        <category>web前端</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础之DOM]]></title>
    <url>%2F2019%2F09%2F30%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8BDOM%2F</url>
    <content type="text"><![CDATA[基础DOMDOM概述Document Object Model ，就是 文档对象模型 大家应该已经对HTML标签了解了，其实DOM和标签之间的关系密不可分，html标签通过浏览器解析成DOM节点。html标签包裹的内容展示在页面上，行为操作是需要DOM来完成的。一个页面有很多的html标签，那么就对应有很多DOM节点。这么多的DOM节点根据父子级的关系构成DOM树。 节点类型 在这里我们就只关注最常用的三种：元素、属性、文本。 元素节点（Element）: html的标签 属性节点（Attribute）:元素属性 比如设置的id 文本节点（Text）: 页面上需要展示的内容 这些节点的属性也都是通用的。有 nodeType(返回节点的属性值)， nodeName(返回节点的名称)， nodeValue(返回或设置当前节点的值)。 123456789101112&lt;div id='main'&gt;&lt;p&gt;这是节点1&lt;/p&gt;&lt;!-- 注释 --&gt;hello&lt;/div&gt; &lt;!-- 第一级child节点 --&gt;&lt;script type="text/javascript"&gt; var divCon = document.getElementById('main'); var con1 = document.getElementsByTagName('p'); //空格和换行符会被解释成节点 for (var i = 0; i &lt; divCon.childNodes.length; i++) &#123; console.log('-------------') console.log("nodeType:"+divCon.childNodes[i].nodeType+""); console.log("nodeName:"+divCon.childNodes[i].nodeName+""); console.log("nodeValue:"+divCon.childNodes[i].nodeValue+""); &#125; &lt;/script&gt; 如果只想要返回元素节点的长度可以用： ele.childElementCount 方法或者 ele.children.length方法 注意： IE浏览器只能使用nodeType 是否等于某个数值 来判断节点类型 属性可以进行获取或设置某个节点的属性值。 innerHTML 节点（元素）的文本值，获取/设置节点内容 parentNode 节点（元素）的父节点 childNodes 节点（元素）的子节点 attributes 节点（元素）的属性节点 style 修改节点样式 当然，还有上述的nodeType，nodeName，nodeValue 属性 属性操作：（也算是方法） 方法 表述 getAttribute(name) 返回指定的属性值 setAttribute(name,value) 把指定属性设置或修改为指定的值。 removeAttribute(name) 删除属性 12345678910111213&lt;div id='main'&gt;&lt;p&gt;这是节点1&lt;/p&gt;&lt;!-- 注释 --&gt;hello&lt;/div&gt; &lt;!-- 第一级child节点 --&gt;&lt;script type="text/javascript"&gt; var divCon = document.getElementById('main'); var con1 = document.getElementsByTagName('p'); console.log(divCon.innerHTML) // &lt;p id="con1"&gt;这是节点1&lt;/p&gt;&lt;!-- 注释 --&gt;hello divCon.innerHTML+=' world' console.log(con1[0]) // &lt;p&gt;这是节点1&lt;/p&gt; console.log(con1[0].parentNode) // 不能直接使用 con1 需要指定是哪一个元素的父元素。 console.log(divCon.childNodes) // 数组 共有三个值，空格和注释都是节点 console.log(divCon.attributes) // id console.log(con1.attributes) // undefined 没有属性 con1[0].style.color = 'red'; // 通过 . 运算符操作&lt;/script&gt; 方法 方法 表述 返回类型 getElementById() 返回指定的属性值 object getElementsByTagName() 把指定属性设置或修改为指定的值。 数组 getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 数组 appendChild(node) 把新的子节点添加到指定节点 removeChild(node) 删除子节点 replaceChild(node1,node2) 替换子节点。node1替换node2 insertBefore(node1,node2) 在指定的子节点前面插入新的子节点。n1插在n2前 createAttribute(node) 创建属性节点。 createElement(node) 创建元素节点。 createTextNode(node) 创建文本节点。 123456789101112131415161718192021var con2 = document.createElement('h1');var con2Attr = document.createAttribute('class');con2Attr.value = 'con2'con2.setAttributeNode(con2Attr)var con2Content = document.createTextNode('这是一级标题');con2.appendChild(con2Content);con1[0].appendChild(con2);console.log(con2); // &lt;h1 class='con2'&gt;这是一级标题&lt;/h1&gt;// con1[0].removeChild(con2); // 去掉刚添加的节点var con3 = document.createElement('a');var con3Attr = document.createAttribute('href');var con3Name = document.createTextNode('Baidu')con3Attr.value='http://baidu.com'con3.setAttributeNode(con3Attr)con3.appendChild(con3Name);console.log(con3);con1[0].replaceChild(con3,con2); // con3 替换了con2con1[0].insertBefore(con2,con3); // 在con3前插入con2 ps：实现一个insertAfter方法 123456789function insertAfter(a1,a2)&#123; var parent = a2.parentNode; if(parent.lastChild == a2) &#123; ​parent.appendChild(a1); &#125;​ else &#123; parent.insertBefore(a1, a2.nextSibling);​ &#125;​&#125;]]></content>
      <categories>
        <category>web前端</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础之语言特性及数据类型]]></title>
    <url>%2F2019%2F09%2F30%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[零、是什么 JavaScript是前端必学语言，和HTML,CSS并称为前端三剑客，是一门运行在浏览器端的脚本语言，功能是操作DOM，处理数据，渲染特效等 一、语言特性1、弱类型说白了就是类型定义，对应的就是强类型，比如Java，C等都是强类型语言，在使用变量的时候必须声明是哪种类型的，一旦被定义了数据类型，除非强制类型转换，那么它到销毁的时候都是这个类型的，这样当然是比较安全的。而弱类型就是不需要定义是什么数据类型，它的值就表示了它是什么类型的。如下： 12345var asd1 = 'have a nice day' //stringvar asd2 = 20 //numbervar asd3 = new Date() //objectvar asd4 = ['1','3','4'] //objectvar asd5 = true //boolean 2、动态性可以直接对用户的操作做出相应，不需要通过Web服务器。采用事件驱动的方式进行，比如你点击一个提交按钮就是一个事件，也就是说你执行某种操作的动作，非常常见。当相关事件在触发的时候就会自动执行需要响应的脚本或函数。 3、运行在浏览器端js脚本语言不允许访问本地硬盘，也不能存储在服务器上，所以它只能通过浏览器实现数据的展示和动态交互，正是因为这样，保证了数据的安全性。 4、跨平台性依赖于浏览器本身，与操作环境无关。只要能运行浏览器的计算机，并安装了支持javascript的浏览器就可以正确执行，从而实现了“编写一次，走遍天下”的梦想。 5、脚本语言解释性脚本语言，javascript不需要编译，只需要嵌入到html代码中，由浏览器逐行加载解释执行 二、基本数据类型JavaScript的基本类型值是保存在栈内存中的简单数据段，按值存储，所以按值访问。基本数据类型有： Number、String、Boolean、Null、Undefined、以及ES6的symbol(独一无二的值)。 用typeof 来检验基本类型，参考弱类型的举例，可以返回这些值：undefined、boolean、string、number、object、function 这里还有一些有意思的例子： 1234typeof undefined //undefinedtypeof null //objecttypeof ['1','2','3'] //objecttypeof &#123;asd:'sssss'&#125; //object 所以不要使用typeof 来区分数组还是对象，因为都返回object。 有时需要根据数组或对象里有没有值来判断是否显示: 如果是数组，arr.length&gt;0。 如果是对象，可以直接拿属性判断 obj.name。但如果不知道有什么属性，可以使用 Object.keys(obj).length &gt; 0 来判断 说说null和undefined的区别。 同：都表示 无 不同： 如果转换为数值 undefined =&gt; NaN 有声明，但未赋值或者未初始化 null =&gt; 0 (原型链的终点) 没有，也没有定义，不存在 12typeof 未定义值 // undefinedtypeof 未初始化值 // undefined 三、进阶JavaScript 的基本知识就是上述，你可能发现好像很简单并不多，那只是基本类型，我们常用到的Object还没有介绍呢，接下来说一下进阶的知识。 1、引用类型和基本类型对应，引用类型是保存在堆内存中的对象，值是可变的，在栈中保存对应的指针（一个指向堆的引用地址），指向堆中实际的值。 类型值：Object（在JS中除了基本数据类型以外的都是对象，数据是对象，函数是对象，正则表达式是对象） 使用 instanceof 检测引用类型 。 需明确确定是哪种类型，返回 布尔值 1234var a = [1,2]var b = &#123;'a':'asss'&#125;alert( a instanceof Array) // truealert( b instanceof Object) // true 除了使用instanceof ,还可以使用一个方法来返回复杂类型的类型值。 123var arr = [3,4,5,6,2,1]var aa = Object.prototype.toString(arr) // '[object Array]'aa.substr(8,aa.length-9) // Array 那么基本类型和引用类型有什么区别呢。 12345678910var arr = [2,4,6];var bcc = arr;//传址 ,对象中传给变量的数据是引用类型的，会存储在堆中；var cxx = arr[0];//传值，把对象中的属性/数组中的数组项赋值给变量，这时变量C是基本数据类型，存储在栈内存中；改变栈中的数据不会影响堆中的数据alert(bcc);//2,4,6alert(cxx);//2//改变数值 bcc[1] = 6;cxx = 7;alert(arr[2]);//6alert(arr[0]);//2 从上面我们可以得知，当我改变bcc中的数据时，arr中数据也发生了变化；但是当我改变cxx的数据值时，arr却没有发生改变。 这就是传值与传址的区别。因为arr是数组，属于引用类型，所以它赋予给bcc的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象。而cxx仅仅是从arr堆内存中获取的一个数据值，并保存在栈中。所以bcc修改的时候，会根据地址回到arr堆中修改，cxx则直接在栈中修改，并且不能指向arr堆内存中。 接下来就涉及到比较常用的深拷贝和浅拷贝，我们放在之后来说 2、类型判断在开发的过程中经常会判断值是否相等来进行下一步的操作，在js中有两个方式判断两个值是否相等。 ** == 等于操作符 ** js是弱类型语言，在使用 == 操作符的时候，会进行强制类型转换 123456789"" == "0" // false0 == "" // true0 == "0" // truefalse == "false" // falsefalse == "0" // truefalse == undefined // falsefalse == null // falsenull == undefined // true" \t\r\n" == 0 // true 因为在强制类型转换的时候规则比较复杂，所以说使用 == 是一个不好的编程习惯，也会带来性能消耗。 === 全等操作符不会进行强制类型转换， 123456789"" === "0" // false0 === "" // false0 === "0" // falsefalse === "false" // falsefalse === "0" // falsefalse === undefined // falsefalse === null // falsenull === undefined // false" \t\r\n" === 0 // false 所以推荐使用 === 操作符。 3、类型转换 所以已经使用了 === 操作符，但是还是会产生很多问题，那么不然我们自己进行类型转换。 转换为 字符类型： 将一个值加上空字符串可以轻松转换为字符串类型 1'' + 10 === '10'; // true 转换为 数字类型: 使用一元的加号操作符，可以把字符串转换为数字。 1+'10' === 10; // true 转换为布尔值： 通过使用 否 操作符两次，可以把一个值转换为布尔型 1234567!!'foo'; // true!!''; // false!!'0'; // true!!'1'; // true!!'-1' // true!!&#123;&#125;; // true!!true; // true 是不是觉得很奇怪呢，这里我们就要说一下 假值 ‘’、0、undefined、null、false、NaN 都是假值，返回 false。 其他的都将是真值，包括对象、数组、正则、函数等。注意 ‘0’、’null’、’false’、{}、[]也都是真值 。 结论： false 0 ‘’ 之间相互比较都是true,null和undefined相互比较是true。其余全是false]]></content>
      <categories>
        <category>web前端</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底理解JavaScript的深拷贝与浅拷贝]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3JavaScript%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[是什么js中有基础类型和引用类型。基础类型是存储在栈内存中的，按值存储，按值访问。基本类型有Number，String，Boolean，Null，Undefined，Symbol引用类型是存储在堆内存中的，值是可变的。在栈中保存对应的指针（一个指向堆的引用地址），指向堆中实际的值。比如数组，对象，正则等，除了基本数据类型，都是引用类型了。 基本类型的复制，是不会相互影响的。因为直接改变的就是栈中的值。而引用类型的复制，在修改其中一个的时候，另一个也会跟着发生变化。是因为复制的是栈中的指针，当改变值时，指针会仍然指向堆中实际的值，所以也就会跟着变化。 举一些例子吧：123456789101112131415161718// 基础类型var a = 2;b = a;console.log(b) //2b = 3;console.log(a, b) //2,3// 引用类型var arr = [2,4,6];var bcc = arr;//传址 ,对象中传给变量的数据是引用类型的，会存储在堆中；var cxx = arr[0];//传值，把对象中的属性/数组中的数组项赋值给变量，这时变量cxx是基本数据类型，存储在栈内存中；改变栈中的数据不会影响堆中的数据console.log(bcc);//2,4,6console.log(cxx);//2//改变数值 bcc[1] = 6;cxx = 7;console.log(arr[1]);//6console.log(arr[0]);//2 从上面我们可以得知，当我改变bcc中的数据时，arr中数据也发生了变化；但是当我改变cxx的数据值时，arr却没有发生改变。 这就是传值与传址的区别。因为arr是数组，属于引用类型，所以它赋予给bcc的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象。而cxx仅仅是从arr堆内存中获取的一个数据值，并保存在栈中。所以bcc修改的时候，会根据地址回到arr堆中修改，cxx则直接在栈中修改，并且不能指向arr堆内存中。 浅拷贝简单来说，引用类型的直接复制，在修改其中一个的时候，另一个就会跟着变化。这种直接复制的方式 就是浅拷贝。浅拷贝是拷贝一层，深层次的对象级别的就拷贝引用 还有一种浅拷贝的方式： ES6中的Object.assign方法，Object.assign是ES6的新函数。Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。 为了解决这个问题，引入深拷贝的方式，其实就是拷贝多层，每一级别的数据都会拷贝出来； 深拷贝的实现方式 手动复制 把一个对象的属性复制给另一个对象的属性 对象只有一层的话可以使用上面的：Object.assign()函数 JSON的方式，先转为字符串，再转为对象 JSON.parse(JSON.stringify(obj)) 缺点：会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。而且只有可以转为json格式对象的才能这样使用。 递归拷贝 1234567891011121314151617181920function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) &#123; continue; &#125; if (typeof prop === 'object') &#123; obj[i] = (prop.constructor === Array) ? [] : &#123;&#125;; arguments.callee(prop, obj[i]); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125;var str = &#123;&#125;;var obj = &#123; a: &#123;a: "hello", b: 21&#125; &#125;;deepClone(obj, str);console.log(str.a); Object.create()方法 123456789101112131415function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) &#123; continue; &#125; if (typeof prop === 'object') &#123; obj[i] = (prop.constructor === Array) ? [] : Object.create(prop); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125;]]></content>
      <categories>
        <category>web前端</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
