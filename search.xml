<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript基础之DOM]]></title>
    <url>%2F2019%2F09%2F30%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8BDOM%2F</url>
    <content type="text"><![CDATA[基础DOMDOM概述Document Object Model ，就是 文档对象模型 大家应该已经对HTML标签了解了，其实DOM和标签之间的关系密不可分，html标签通过浏览器解析成DOM节点。html标签包裹的内容展示在页面上，行为操作是需要DOM来完成的。一个页面有很多的html标签，那么就对应有很多DOM节点。这么多的DOM节点根据父子级的关系构成DOM树。 节点类型 在这里我们就只关注最常用的三种：元素、属性、文本。 元素节点（Element）: html的标签 属性节点（Attribute）:元素属性 比如设置的id 文本节点（Text）: 页面上需要展示的内容 这些节点的属性也都是通用的。有 nodeType(返回节点的属性值)， nodeName(返回节点的名称)， nodeValue(返回或设置当前节点的值)。 123456789101112&lt;div id='main'&gt;&lt;p&gt;这是节点1&lt;/p&gt;&lt;!-- 注释 --&gt;hello&lt;/div&gt; &lt;!-- 第一级child节点 --&gt;&lt;script type="text/javascript"&gt; var divCon = document.getElementById('main'); var con1 = document.getElementsByTagName('p'); //空格和换行符会被解释成节点 for (var i = 0; i &lt; divCon.childNodes.length; i++) &#123; console.log('-------------') console.log("nodeType:"+divCon.childNodes[i].nodeType+""); console.log("nodeName:"+divCon.childNodes[i].nodeName+""); console.log("nodeValue:"+divCon.childNodes[i].nodeValue+""); &#125; &lt;/script&gt; 如果只想要返回元素节点的长度可以用： ele.childElementCount 方法或者 ele.children.length方法 注意： IE浏览器只能使用nodeType 是否等于某个数值 来判断节点类型 属性可以进行获取或设置某个节点的属性值。 innerHTML 节点（元素）的文本值，获取/设置节点内容 parentNode 节点（元素）的父节点 childNodes 节点（元素）的子节点 attributes 节点（元素）的属性节点 style 修改节点样式 当然，还有上述的nodeType，nodeName，nodeValue 属性 属性操作：（也算是方法） 方法 表述 getAttribute(name) 返回指定的属性值 setAttribute(name,value) 把指定属性设置或修改为指定的值。 removeAttribute(name) 删除属性 12345678910111213&lt;div id='main'&gt;&lt;p&gt;这是节点1&lt;/p&gt;&lt;!-- 注释 --&gt;hello&lt;/div&gt; &lt;!-- 第一级child节点 --&gt;&lt;script type="text/javascript"&gt; var divCon = document.getElementById('main'); var con1 = document.getElementsByTagName('p'); console.log(divCon.innerHTML) // &lt;p id="con1"&gt;这是节点1&lt;/p&gt;&lt;!-- 注释 --&gt;hello divCon.innerHTML+=' world' console.log(con1[0]) // &lt;p&gt;这是节点1&lt;/p&gt; console.log(con1[0].parentNode) // 不能直接使用 con1 需要指定是哪一个元素的父元素。 console.log(divCon.childNodes) // 数组 共有三个值，空格和注释都是节点 console.log(divCon.attributes) // id console.log(con1.attributes) // undefined 没有属性 con1[0].style.color = 'red'; // 通过 . 运算符操作&lt;/script&gt; 方法 方法 表述 返回类型 getElementById() 返回指定的属性值 object getElementsByTagName() 把指定属性设置或修改为指定的值。 数组 getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 数组 appendChild(node) 把新的子节点添加到指定节点 removeChild(node) 删除子节点 replaceChild(node1,node2) 替换子节点。node1替换node2 insertBefore(node1,node2) 在指定的子节点前面插入新的子节点。n1插在n2前 createAttribute(node) 创建属性节点。 createElement(node) 创建元素节点。 createTextNode(node) 创建文本节点。 123456789101112131415161718192021var con2 = document.createElement('h1');var con2Attr = document.createAttribute('class');con2Attr.value = 'con2'con2.setAttributeNode(con2Attr)var con2Content = document.createTextNode('这是一级标题');con2.appendChild(con2Content);con1[0].appendChild(con2);console.log(con2); // &lt;h1 class='con2'&gt;这是一级标题&lt;/h1&gt;// con1[0].removeChild(con2); // 去掉刚添加的节点var con3 = document.createElement('a');var con3Attr = document.createAttribute('href');var con3Name = document.createTextNode('Baidu')con3Attr.value='http://baidu.com'con3.setAttributeNode(con3Attr)con3.appendChild(con3Name);console.log(con3);con1[0].replaceChild(con3,con2); // con3 替换了con2con1[0].insertBefore(con2,con3); // 在con3前插入con2 ps：实现一个insertAfter方法 123456789function insertAfter(a1,a2)&#123; var parent = a2.parentNode; if(parent.lastChild == a2) &#123; ​parent.appendChild(a1); &#125;​ else &#123; parent.insertBefore(a1, a2.nextSibling);​ &#125;​&#125;]]></content>
      <categories>
        <category>web前端</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础之语言特性及数据类型]]></title>
    <url>%2F2019%2F09%2F30%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[零、是什么 JavaScript是前端必学语言，和HTML,CSS并称为前端三剑客，是一门运行在浏览器端的脚本语言，功能是操作DOM，处理数据，渲染特效等 一、语言特性1、弱类型说白了就是类型定义，对应的就是强类型，比如Java，C等都是强类型语言，在使用变量的时候必须声明是哪种类型的，一旦被定义了数据类型，除非强制类型转换，那么它到销毁的时候都是这个类型的，这样当然是比较安全的。而弱类型就是不需要定义是什么数据类型，它的值就表示了它是什么类型的。如下： 12345var asd1 = 'have a nice day' //stringvar asd2 = 20 //numbervar asd3 = new Date() //objectvar asd4 = ['1','3','4'] //objectvar asd5 = true //boolean 2、动态性可以直接对用户的操作做出相应，不需要通过Web服务器。采用事件驱动的方式进行，比如你点击一个提交按钮就是一个事件，也就是说你执行某种操作的动作，非常常见。当相关事件在触发的时候就会自动执行需要响应的脚本或函数。 3、运行在浏览器端js脚本语言不允许访问本地硬盘，也不能存储在服务器上，所以它只能通过浏览器实现数据的展示和动态交互，正是因为这样，保证了数据的安全性。 4、跨平台性依赖于浏览器本身，与操作环境无关。只要能运行浏览器的计算机，并安装了支持javascript的浏览器就可以正确执行，从而实现了“编写一次，走遍天下”的梦想。 5、脚本语言解释性脚本语言，javascript不需要编译，只需要嵌入到html代码中，由浏览器逐行加载解释执行 二、基本数据类型JavaScript的基本类型值是保存在栈内存中的简单数据段，按值存储，所以按值访问。基本数据类型有： Number、String、Boolean、Null、Undefined、以及ES6的symbol(独一无二的值)。 用typeof 来检验基本类型，参考弱类型的举例，可以返回这些值：undefined、boolean、string、number、object、function 这里还有一些有意思的例子： 1234typeof undefined //undefinedtypeof null //objecttypeof ['1','2','3'] //objecttypeof &#123;asd:'sssss'&#125; //object 所以不要使用typeof 来区分数组还是对象，因为都返回object。 有时需要根据数组或对象里有没有值来判断是否显示: 如果是数组，arr.length&gt;0。 如果是对象，可以直接拿属性判断 obj.name。但如果不知道有什么属性，可以使用 Object.keys(obj).length &gt; 0 来判断 说说null和undefined的区别。 同：都表示 无 不同： 如果转换为数值 undefined =&gt; NaN 有声明，但未赋值或者未初始化 null =&gt; 0 (原型链的终点) 没有，也没有定义，不存在 12typeof 未定义值 // undefinedtypeof 未初始化值 // undefined 三、进阶JavaScript 的基本知识就是上述，你可能发现好像很简单并不多，那只是基本类型，我们常用到的Object还没有介绍呢，接下来说一下进阶的知识。 1、引用类型和基本类型对应，引用类型是保存在堆内存中的对象，值是可变的，在栈中保存对应的指针（一个指向堆的引用地址），指向堆中实际的值。 类型值：Object（在JS中除了基本数据类型以外的都是对象，数据是对象，函数是对象，正则表达式是对象） 使用 instanceof 检测引用类型 。 需明确确定是哪种类型，返回 布尔值 1234var a = [1,2]var b = &#123;'a':'asss'&#125;alert( a instanceof Array) // truealert( b instanceof Object) // true 除了使用instanceof ,还可以使用一个方法来返回复杂类型的类型值。 123var arr = [3,4,5,6,2,1]var aa = Object.prototype.toString(arr) // '[object Array]'aa.substr(8,aa.length-9) // Array 那么基本类型和引用类型有什么区别呢。 12345678910var arr = [2,4,6];var bcc = arr;//传址 ,对象中传给变量的数据是引用类型的，会存储在堆中；var cxx = arr[0];//传值，把对象中的属性/数组中的数组项赋值给变量，这时变量C是基本数据类型，存储在栈内存中；改变栈中的数据不会影响堆中的数据alert(bcc);//2,4,6alert(cxx);//2//改变数值 bcc[1] = 6;cxx = 7;alert(arr[2]);//6alert(arr[0]);//2 从上面我们可以得知，当我改变bcc中的数据时，arr中数据也发生了变化；但是当我改变cxx的数据值时，arr却没有发生改变。 这就是传值与传址的区别。因为arr是数组，属于引用类型，所以它赋予给bcc的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象。而cxx仅仅是从arr堆内存中获取的一个数据值，并保存在栈中。所以bcc修改的时候，会根据地址回到arr堆中修改，cxx则直接在栈中修改，并且不能指向arr堆内存中。 接下来就涉及到比较常用的深拷贝和浅拷贝，我们放在之后来说 2、类型判断在开发的过程中经常会判断值是否相等来进行下一步的操作，在js中有两个方式判断两个值是否相等。 ** == 等于操作符 ** js是弱类型语言，在使用 == 操作符的时候，会进行强制类型转换 123456789"" == "0" // false0 == "" // true0 == "0" // truefalse == "false" // falsefalse == "0" // truefalse == undefined // falsefalse == null // falsenull == undefined // true" \t\r\n" == 0 // true 因为在强制类型转换的时候规则比较复杂，所以说使用 == 是一个不好的编程习惯，也会带来性能消耗。 === 全等操作符不会进行强制类型转换， 123456789"" === "0" // false0 === "" // false0 === "0" // falsefalse === "false" // falsefalse === "0" // falsefalse === undefined // falsefalse === null // falsenull === undefined // false" \t\r\n" === 0 // false 所以推荐使用 === 操作符。 3、类型转换 所以已经使用了 === 操作符，但是还是会产生很多问题，那么不然我们自己进行类型转换。 转换为 字符类型： 将一个值加上空字符串可以轻松转换为字符串类型 1'' + 10 === '10'; // true 转换为 数字类型: 使用一元的加号操作符，可以把字符串转换为数字。 1+'10' === 10; // true 转换为布尔值： 通过使用 否 操作符两次，可以把一个值转换为布尔型 1234567!!'foo'; // true!!''; // false!!'0'; // true!!'1'; // true!!'-1' // true!!&#123;&#125;; // true!!true; // true 是不是觉得很奇怪呢，这里我们就要说一下 假值 ‘’、0、undefined、null、false、NaN 都是假值，返回 false。 其他的都将是真值，包括对象、数组、正则、函数等。注意 ‘0’、’null’、’false’、{}、[]也都是真值 。 结论： false 0 ‘’ 之间相互比较都是true,null和undefined相互比较是true。其余全是false]]></content>
      <categories>
        <category>web前端</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底理解JavaScript的深拷贝与浅拷贝]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3JavaScript%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[是什么js中有基础类型和引用类型。基础类型是存储在栈内存中的，按值存储，按值访问。基本类型有Number，String，Boolean，Null，Undefined，Symbol引用类型是存储在堆内存中的，值是可变的。在栈中保存对应的指针（一个指向堆的引用地址），指向堆中实际的值。比如数组，对象，正则等，除了基本数据类型，都是引用类型了。 基本类型的复制，是不会相互影响的。因为直接改变的就是栈中的值。而引用类型的复制，在修改其中一个的时候，另一个也会跟着发生变化。是因为复制的是栈中的指针，当改变值时，指针会仍然指向堆中实际的值，所以也就会跟着变化。 举一些例子吧：123456789101112131415161718// 基础类型var a = 2;b = a;console.log(b) //2b = 3;console.log(a, b) //2,3// 引用类型var arr = [2,4,6];var bcc = arr;//传址 ,对象中传给变量的数据是引用类型的，会存储在堆中；var cxx = arr[0];//传值，把对象中的属性/数组中的数组项赋值给变量，这时变量cxx是基本数据类型，存储在栈内存中；改变栈中的数据不会影响堆中的数据console.log(bcc);//2,4,6console.log(cxx);//2//改变数值 bcc[1] = 6;cxx = 7;console.log(arr[1]);//6console.log(arr[0]);//2 从上面我们可以得知，当我改变bcc中的数据时，arr中数据也发生了变化；但是当我改变cxx的数据值时，arr却没有发生改变。 这就是传值与传址的区别。因为arr是数组，属于引用类型，所以它赋予给bcc的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象。而cxx仅仅是从arr堆内存中获取的一个数据值，并保存在栈中。所以bcc修改的时候，会根据地址回到arr堆中修改，cxx则直接在栈中修改，并且不能指向arr堆内存中。 浅拷贝简单来说，引用类型的直接复制，在修改其中一个的时候，另一个就会跟着变化。这种直接复制的方式 就是浅拷贝。浅拷贝是拷贝一层，深层次的对象级别的就拷贝引用 还有一种浅拷贝的方式： ES6中的Object.assign方法，Object.assign是ES6的新函数。Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。 为了解决这个问题，引入深拷贝的方式，其实就是拷贝多层，每一级别的数据都会拷贝出来； 深拷贝的实现方式 手动复制 把一个对象的属性复制给另一个对象的属性 对象只有一层的话可以使用上面的：Object.assign()函数 JSON的方式，先转为字符串，再转为对象 JSON.parse(JSON.stringify(obj)) 缺点：会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。而且只有可以转为json格式对象的才能这样使用。 递归拷贝 1234567891011121314151617181920function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) &#123; continue; &#125; if (typeof prop === 'object') &#123; obj[i] = (prop.constructor === Array) ? [] : &#123;&#125;; arguments.callee(prop, obj[i]); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125;var str = &#123;&#125;;var obj = &#123; a: &#123;a: "hello", b: 21&#125; &#125;;deepClone(obj, str);console.log(str.a); Object.create()方法 123456789101112131415function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) &#123; continue; &#125; if (typeof prop === 'object') &#123; obj[i] = (prop.constructor === Array) ? [] : Object.create(prop); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125;]]></content>
      <categories>
        <category>web前端</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
